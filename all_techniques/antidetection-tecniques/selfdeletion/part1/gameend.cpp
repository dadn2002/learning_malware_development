#include "../../../imports.h"

/* Information
    merge the code with
    gcc -o main.exe main.cpp error.obj debugger.obj 
*/

#define NEW_STREAM L":SPAWN"
extern "C" PPEB GetPEB(void);
extern "C" DWORD CustomError(void);

BOOL CheckDebugger(void){
    info("getting PEB");
    PPEB pPEB = GetPEB();

    okay("\\___[ PEB\n\t\\_0x%p]", pPEB);
    info("checking for debugger presence");
    okay("[PEB->BeingDebugged: 0x%d]", pPEB->BeingDebugged);

    if(pPEB->BeingDebugged != 0){
        warn("being debugged!");
        return TRUE;
    }

    okay("not being debugged!");
    return FALSE;
}

int SelfDelete(void){

    HANDLE                      hFile                   = INVALID_HANDLE_VALUE;
    const wchar_t*              NEWSTREAM               = (const wchar_t*)NEW_STREAM;
    size_t                      RenameSize              = sizeof(FILE_RENAME_INFO) + sizeof(NEWSTREAM);
    PFILE_RENAME_INFO           PFRI                    = NULL;
    WCHAR                       PathSize[MAX_PATH * 2]  = { 0 }; 
    FILE_DISPOSITION_INFO       SetDelete               = { 0 };

    /* Information _FILE_RENAME_INFO

    typedef struct _FILE_RENAME_INFO {
        union {
            BOOLEAN ReplaceIfExists;
            DWORD   Flags;
        } DUMMYUNIONNAME;
        BOOLEAN ReplaceIfExists;
        HANDLE  RootDirectory;
        DWORD   FileNameLength;
        WCHAR   FileName[1];
    } FILE_RENAME_INFO, *PFILE_RENAME_INFO;

    more info:
    https://learn.microsoft.com/en-us/windows/win32/api/WinBase/ns-winbase-file_rename_info
    */
    /* Information _FILE_DISPOSITION_INFO

    Indicates whether a file should be deleted. Used for any handles. 
    Use only when calling SetFileInformationByHandle.

    typedef struct _FILE_DISPOSITION_INFO {
        BOOLEAN DeleteFile;
    } FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;

    more info:
    https://learn.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-file_disposition_info
    */

    /* [ALLOC BUFFER FOR FILE_RENAME_INFO] */
    PFRI = (PFILE_RENAME_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, RenameSize);
    if (!PFRI){
        warn("[HeapAlloc] failed to allocate memory, error: 0x%lx", CustomError());
        return 1;
    }
    okay("allocated memory for FILE_RENAME_INFO [0x%p]", PFRI);
    info("cleaning up some structures");

    ZeroMemory(PathSize, sizeof(PathSize));
    ZeroMemory(&SetDelete, sizeof(FILE_DISPOSITION_INFO));
    okay("finished!");

    /*---------------------------------------[MARK FILE FOR DELETION]-------------------------------------*/
    info("setting file for deletion");
    SetDelete.DeleteFile = TRUE;
    okay("finished!");

    /*------------------------[SET NEW DATA STREAM BUFFER & SIZE IN FILE_RENAME_INFO]---------------------*/
    PFRI->FileNameLength = sizeof(NEWSTREAM);
    okay("set FILE_RENAME_INFO->FileNameLength to %S", NEWSTREAM);
    RtlCopyMemory(PFRI->FileName, NEWSTREAM, sizeof(NEWSTREAM));
    okay("overwrote FILE_RENAME_INFO->FileName with %S data stream", NEWSTREAM);
    okay("\\___[ FILE_RENAME_INFO->FileName\n\t\\_0x%S]", PFRI->FileName);

    /*----------------------------------------[GET CURRENT FILENAME]-------------------------------------*/
    info("getting current filename");
    if (GetModuleFileNameW(NULL, PathSize, MAX_PATH * 2) == 0){
        warn("[GetModuleFileNameW] failed to get filename, error: 0x%lx", CustomError());
        return 1;
    }
    okay("finished");

    /*------------------------------------------[GET FILE HANDLE]-----------------------------------------*/
    info("starting the remaining process");
    info("getting handle of the current file");
    hFile = CreateFileW(PathSize, (DELETE | SYNCHRONIZE), FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE){
        warn("[CreateFileW] failed to get a handle to the file, error: 0x%lx", CustomError());
        return 1;
    }
    okay("\\___[ hFile\n\t\\_0x%p]", hFile);
    info("renaming");

    /*----------------------------------------------[RENAME]----------------------------------------------*/
    if (!SetFileInformationByHandle(hFile, FileRenameInfo, PFRI, RenameSize)){
        warn("[SetFileInformationByHandle] failed to rewrite the data stream, error: 0x%lx", CustomError());
    }
    okay("finished!");
    info("closing handle to push change");
    CloseHandle(hFile);
    okay("done! now beginning stage II");

    /*--------------------------------------------[DELETION II]--------------------------------------------*/

    info("getting handle of the current file, again");
    hFile = CreateFileW(PathSize, (DELETE | SYNCHRONIZE), FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE){
        warn("[CreateFileW] failed to get a handle to the file, error: 0x%lx", CustomError());
        return 1;
    }
    okay("\\___[ hFile\n\t\\_0x%p]", hFile);
    
    info("setting file for deletion");
    if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &SetDelete, sizeof(SetDelete))){
        warn("[SetFileInformationByHandle] failed to mark file for deletion, error: 0x%lx", CustomError());
        return 1;
    }
    okay("finished!");
    info("closing handle to file, this should delete the file");

    CloseHandle(hFile);
    info("cleaning the allocated heap buffer");
    HeapFree(GetProcessHeap(), 0, PFRI);

    return 0;
}

int main(void){
    if(!CheckDebugger()){
        info("executing malware");
        MessageBoxW(NULL, L"Hello", L"Whos There", MB_ICONEXCLAMATION);
        return 0;
    }
    
    info("where being watched!");
    SelfDelete();
}