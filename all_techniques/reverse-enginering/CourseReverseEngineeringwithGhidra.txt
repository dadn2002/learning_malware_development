
OUTPUT FORMATS
    The output of compilation process
    PE (Windows)
    ELF (Linux)
    Mach-O (OSX)
    COFF/ECOFF

    ELF Overview
        ELF = Executable Linking Format 
        Contain information about OS, endianness, etc 
        ELF files provide information needed for the execution by the OS
        ELF files can be divided into
            ELF header
            Sections
            Segments
        
        SYMBOLS
            Are used to aid in debugging, providing context (Dont knowing them make your task harder)
            ELF objects contain a maximum of 2 symbols tables
                .symtab: containing symbols for debugging/labbeling
                .dynsym: containing symbols for dynamic linking

        ELF files define how the program is laid out in memory
            Used by the OS loader to create a process
        ELF files contain machine code.
        Exist many tools for analysing and read ELF files
            dumpelf
            readelf
            objdump
            elfutils

        Information can be limited when performing RE 
            Understanding core concepts is important
            File formats can be a treasure trove of information
        
        Our goal is to work backwards from the machine code
            The ELF file will contain machine code
            This machine code can be converted back into assembly language
            Machine code -> Assembly Language = Disassembly!

COMPUTER ARQUITECTURE
    When a program is running, the following must happen
        An instruction is read into memory
        The instruction is processed by the ALU (Arithmetic Logic Unit)
        The result of the operationis stored in a register or memory.

    We'll take about C programs being deconstructed into 4 components
        Registers
        Instructions
        Stack
        Heap

    Routine
        Main memory  -> fetch instruction   -> 
        Control Unit -> Decode instructions ->
        ALU          -> Execute commands    -> Store results in memory ->

    We'll focus on intel x86-64 arquitecture.
    Original especification was created by AMD in 2000.

    Registers (Special Ones)
        RIP: instruction pointer
            Points to the next instruction to be executed
            64 bits.
        RFLAGS: Stores flags used for processor flow Control.
        FRP0-FPR7: Floating point status and control registers.
        RBP/RSP: Stack manipulation and usage.

    Instructions 
        These defines the operations being performed by the CPU
        We'll focus on intel syntax
            instruction dst, src
        Instructions can have multiple operands
            These define the arguments for the specified operation
        X86_64 has a large amount of instructions
            We'll focus on the commum ones first

        List of instructions:
            mov
                moves data from one register to another
                mov rax, rbx
                    moves the value stored in rbx into rax
                mov rax, [rbx]
                    moves the value pointed to by rbx into rax
            add/sub
                (works as you think)
            and/xor/or
                (works as you think in boolean algebra)
            jmp/call
                jmp is used to change what code is being executed
                    modifies the value in RIP
                    jmp 0x1000300
                        set RIP to 0x1000300 and execute the instruction here
                    also can put a condition based on the RFLAGS register
                        je:  jmp if equal zero
                        jne: jmp if equal nonzero
                        jg:  jmp if greater (signed)
                        jl:  jmp if less (signed)
                call is used to implement function calls
                    pushes value of rbp and rip onto stack before jumping
                    call 0x18000000
            cmp
                performs a comparison operation by subtracting the operands
                    No storage is performed
                    Based on the result, fields in RFLAGS are set
                    cmp rax, #5
                The flags in RFLAGS are used by jmp variants
                    je:  jmp if equal zero
                    jne: jmp if equal nonzero
        
        The Stack
            Data structure containing elements in contiguous memory
                POP: Reads from stack
                    will load the value pointed to by rsp into the operand
                    pop rax
                        loads the value pointed by rsp into rbx, and decreases rsp by 8
                PUSH: Writes to stack
                    grow the stack by 8 and store the operand contents on stack
                    push rax
                        increases the value pointed to by rsp by 8, and stores rax there
            Elements are removed in reverse order that they are added
            Grows high to low
            RSP points to top of stack
            RBP contains base pointer
        
        Programming Logic
            if/else
                0 mov rcx, 5
                1 xor eax, eax
                2 mov ebx, 1 
                2 cmp eax, ebx (Sets the RFLAGS)
                3 jmp rcx      (Check if RFLAGS = 0, if yes, jump 5, else continue)
                4 xor rbx, rbx (in this case, that does not  run)
                5 xor rcx, rcx (that always run)
            














