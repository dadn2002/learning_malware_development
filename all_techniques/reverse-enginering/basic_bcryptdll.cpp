#include <windows.h>
#include <bcrypt.h>
#include <stdio.h>

#pragma comment(lib, "bcrypt.lib")

/*  How to compile
    g++ .\basic_bcryptdll.cpp -o .\basic_bcryptdll.exe -lbcrypt
*/

void HandleError(const char* msg, NTSTATUS status) {
    printf("%s failed with status code: 0x%x\n", msg, status);
    exit(status);
}

void EncryptMessage(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hKey, const BYTE* plaintext, DWORD plaintextSize, BYTE* ciphertext, DWORD& ciphertextSize) {
    NTSTATUS status;
    DWORD resultSize = 0;

    // Calculate the size of the ciphertext buffer
    status = BCryptEncrypt(hKey, (PUCHAR)plaintext, plaintextSize, nullptr, nullptr, 0, nullptr, 0, &ciphertextSize, BCRYPT_BLOCK_PADDING);
    if (!BCRYPT_SUCCESS(status)) {
        HandleError("BCryptEncrypt (size calculation)", status);
    }

    // Perform the encryption
    status = BCryptEncrypt(hKey, (PUCHAR)plaintext, plaintextSize, nullptr, nullptr, 0, ciphertext, ciphertextSize, &resultSize, BCRYPT_BLOCK_PADDING);
    if (!BCRYPT_SUCCESS(status)) {
        HandleError("BCryptEncrypt", status);
    }

    ciphertextSize = resultSize;
}

void DecryptMessage(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hKey, const BYTE* ciphertext, DWORD ciphertextSize, BYTE* plaintext, DWORD& plaintextSize) {
    NTSTATUS status;
    DWORD resultSize = 0;

    // Calculate the size of the plaintext buffer
    status = BCryptDecrypt(hKey, (PUCHAR)ciphertext, ciphertextSize, nullptr, nullptr, 0, nullptr, 0, &plaintextSize, BCRYPT_BLOCK_PADDING);
    if (!BCRYPT_SUCCESS(status)) {
        HandleError("BCryptDecrypt (size calculation)", status);
    }

    // Perform the decryption
    status = BCryptDecrypt(hKey, (PUCHAR)ciphertext, ciphertextSize, nullptr, nullptr, 0, plaintext, plaintextSize, &resultSize, BCRYPT_BLOCK_PADDING);
    if (!BCRYPT_SUCCESS(status)) {
        HandleError("BCryptDecrypt", status);
    }

    plaintextSize = resultSize;
}

int main() {
    NTSTATUS status;
    BCRYPT_ALG_HANDLE hAlgorithm = nullptr;
    BCRYPT_KEY_HANDLE hKey = nullptr;
    BYTE key[32] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                     0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };
    BYTE plaintext[] = "Hello World!";
    BYTE ciphertext[128] = { 0 };
    BYTE decryptedtext[128] = { 0 };
    DWORD ciphertextSize = 0, decryptedtextSize = 0;

    system("pause");
    // Open an algorithm handle
    status = BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_AES_ALGORITHM, nullptr, 0);
    if (!BCRYPT_SUCCESS(status)) {
        HandleError("BCryptOpenAlgorithmProvider", status);
    }

    // Generate a symmetric key
    status = BCryptGenerateSymmetricKey(hAlgorithm, &hKey, nullptr, 0, key, sizeof(key), 0);
    if (!BCRYPT_SUCCESS(status)) {
        HandleError("BCryptGenerateSymmetricKey", status);
    }

    // Encrypt the message
    EncryptMessage(hAlgorithm, hKey, plaintext, sizeof(plaintext) - 1, ciphertext, ciphertextSize);

    // Decrypt the message
    DecryptMessage(hAlgorithm, hKey, ciphertext, ciphertextSize, decryptedtext, decryptedtextSize);

    // Print the results
    printf("Plaintext: %s\n", plaintext);

    printf("Ciphertext[hex]: ");
    for (DWORD i = 0; i < ciphertextSize; i++) {
        printf("%02x ", ciphertext[i]);
    }
    printf("\n");

    printf("Ciphertext[ascii]: ");
    for (DWORD i = 0; i < ciphertextSize; i++) {
        printf("%c ", ciphertext[i] + 32);
    }
    printf("\n");

    printf("Decrypted text: %.*s\n", decryptedtextSize, decryptedtext);

    // Clean up
    if (hKey) {
        BCryptDestroyKey(hKey);
    }
    if (hAlgorithm) {
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
    }

    return 0;
}
