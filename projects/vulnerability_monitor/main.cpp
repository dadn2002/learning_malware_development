#include "../imports.h"
#include "functions_header.h"

#include <cstdio>
#include <thread>
#include <atomic>
#include <csignal>

/*  Compiling instructions
        g++ -c main.cpp -o main.o
        g++ -c menu_functions.cpp -o menu_functions.o
        g++ main.o menu_functions.o -o main.exe
*/

// Shared variable and synchronization object
std::atomic<bool> shutdownProgram(false);
volatile int sharedVariable = 0;
int running_mode = 0;
HANDLE hExampleFunction;

int Counter = 0;
LPVOID lpCounter = &Counter;

void signalHandler(int signal) {
    if (signal == SIGINT) {
        printf("Ctrl+C pressed. Shutting down...\n");
        shutdownProgram = true;
    }
}

// Long-running function that updates the shared variable
DWORD WINAPI exampleAsyncFunction(LPVOID lpParam) {
    while (!shutdownProgram) {
        // Simulate some work
        Sleep(1000); // Sleep for 1 second

        // Update the shared variable
        WaitForSingleObject(hExampleFunction, INFINITE);
        sharedVariable++;
        ReleaseMutex(hExampleFunction);
    }
    return 0; // This line will be reached when shutdownProgram is true
}

void read_variables_values(){
    WaitForSingleObject(hExampleFunction, INFINITE);
    info("[sharedVariable] %d", sharedVariable);
    ReleaseMutex(hExampleFunction);

    info("[lpCounter] %p %d", lpCounter, *reinterpret_cast<int*>(lpCounter));
}

bool create_thread_for_async_function(HANDLE &useThisHandle, LPTHREAD_START_ROUTINE useThisFunction){
    useThisHandle = CreateMutex(NULL, FALSE, NULL);

    if (useThisHandle == NULL) {
        printf("CreateMutex error: %lu\n", GetLastError());
        return FALSE;
    }

    printf("Starting long-running function asynchronously...\n");

    // Create a thread to run the long-running function
    DWORD threadId;
    HANDLE hThread = CreateThread(
        NULL,                    // default security attributes
        0,                       // use default stack size
        useThisFunction,         // thread function name
        NULL,                    // argument to thread function
        0,                       // use default creation flags
        &threadId);              // returns the thread identifier

    if (hThread == NULL) {
        printf("[CreateThread] Error: %lu\n", GetLastError());
        CloseHandle(useThisHandle);
        return FALSE;
    }

    // Wait for the thread to finish (which will never happen in this case)
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    CloseHandle(useThisHandle);
    return TRUE;
}

void asyncRoutines() {
    create_thread_for_async_function(hExampleFunction, exampleAsyncFunction);
}

BOOLEAN call_hook(int hookPid){
    info("dllhook start");
    read_variables_values();
    injectCode(hookPid, "ntdll.dll", "NtOpenProcess", lpCounter);
    system("pause");
    return TRUE;
}

void mainRoutine() {
    // Periodically check the shared variable
    int menu_action = 0;

    menu_info();
    while (!shutdownProgram) {
        /*
            // Read the shared variable
            WaitForSingleObject(hMutex, INFINITE);
            int currentValue = sharedVariable;
            ReleaseMutex(hMutex);

            printf("Current value of shared variable: %d\n", currentValue);
        */
        scanf("%d", &menu_action);
        switch (menu_action) {
            case 1: {
                system("cls");
                int hookPID;
                info("Insert hookPID");
                scanf("%d", &hookPID);
                call_hook(hookPID);
                menu_info();
                break;
            }
            case 2:
                menu_info();
                break;
            case 3:
                system("cls");
                menu_info();
                break;
            case 4:
                read_variables_values();
                menu_info();
                break;
            case -1: {
                system("cls");
                // Read the shared variable
                WaitForSingleObject(hExampleFunction, INFINITE);
                int currentValue = sharedVariable;
                ReleaseMutex(hExampleFunction);

                debug("[hExampleFunction] [sharedVariable]: %d\n", currentValue);
                menu_info();
                break;
            }
            default:
                system("cls");
                warn("Non implemented action\n");
                menu_info();
                break;
        }
    }
}

int main(int argc, char* argv[]) {
    // Register signal handler
    signal(SIGINT, signalHandler);

    std::thread asyncThread(asyncRoutines);

    // Run the main routine in the main thread
    mainRoutine();

    // Set the shutdown flag and wait for the async thread to finish
    shutdownProgram = true;
    asyncThread.join();

    return 0;
}
