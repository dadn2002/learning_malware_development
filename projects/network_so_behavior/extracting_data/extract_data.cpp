
#include "../../imports.h"
#include "functions_header.h"
//#include <windows.h>

/*  Compiling instructions
        g++ -c main.cpp -o main.o
        g++ -c menu_functions.cpp -o menu_functions.o
        g++ main.o menu_functions.o -o main.exe
*/

//  Shared variables
bool debugEnabled = false;
const char* list_of_ignored_processes[] = {"extract_data.exe", "[System Process]"};

// Saddly i could only think of redefining my macro :(
#undef debug
#define debug(msg, ...) do { if (debugEnabled) printf("[%] " msg "\n", ##__VA_ARGS__); } while (0)

void toLowercase(char* str) {
    while (*str) {
        *str = tolower(*str); // Convert current character to lowercase
        str++; // Move to the next character
    }
}

void get_exported_functions(DWORD PID, char* moduleName) {
    //toLowercase(moduleName);
    //moduleName = "bcrypt.dll";
    info("Export table of %s in %d", moduleName, PID);
    /*  PROCESS_VM_READ is not enough permission to view export/import table
        Also if this function is not called, the processes allow the snapshot
        If you call this function after the OpenProcess, the program declines 
        the snapshot which is strange
    */
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
    if (hProcess == NULL) {
        warn("[OpenProcess] failed to get handle to %d. Error: %lx", PID, GetLastError());
        return;
    }

    HMODULE hModule = GetModuleHandleA(moduleName);
    if (hModule == NULL) {
        warn("[GetModuleHandleA] failed to get handle to %s. Error: %lx", moduleName, GetLastError());
        return;
    }

    MODULEINFO moduleInfo;
    if (!GetModuleInformation(hProcess, hModule, &moduleInfo, sizeof(moduleInfo))) {
        warn("[GetModuleInformation] failed to get info about %s. Error: %lx", moduleName, GetLastError());
        return;
    }

    BYTE*                      moduleBase                 = reinterpret_cast<BYTE*>(moduleInfo.lpBaseOfDll);
    PIMAGE_DOS_HEADER          dosHeader                  = reinterpret_cast<PIMAGE_DOS_HEADER>(moduleBase);
    PIMAGE_NT_HEADERS          ntHeaders                  = reinterpret_cast<PIMAGE_NT_HEADERS>(moduleBase + dosHeader->e_lfanew);
    PIMAGE_EXPORT_DIRECTORY    exportDir                  = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(moduleBase + ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    DWORD*                     addressOfFunctions         = reinterpret_cast<DWORD*>(moduleBase + exportDir->AddressOfFunctions);
    DWORD*                     addressOfNames             = reinterpret_cast<DWORD*>(moduleBase + exportDir->AddressOfNames);
    WORD*                      addressOfNameOrdinals      = reinterpret_cast<WORD*>(moduleBase + exportDir->AddressOfNameOrdinals);

    info("Printing export table!");
    for (DWORD i = 0; i < exportDir->NumberOfFunctions; ++i) {
        const char* functionName = reinterpret_cast<const char*>(moduleBase + addressOfNames[i]);
        info("Exported function: %s", functionName);
    }
}

char** get_all_modules_info_of_PID(DWORD PID, int* numModules) {
    //CreateToolHelp32Snapshot is powerfull
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, PID);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        switch (GetLastError()){
            case 5:
                warn("PID: %-6d, Denied Access", PID);
                break;
            case 299:
                warn("PID: %-6d, Error Memory Management", PID);
                break;
            default:
                warn("PID: %-6d, [CreateToolhelp32Snapshot] failed to get handle, Error: %lx", GetLastError());
                break;
        }
        *numModules = 0;
        return nullptr;
    }

    MODULEENTRY32 moduleEntry;
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    int count = 0;
    if (Module32First(hSnapshot, &moduleEntry)) {
        do {
            ++count;
        } while (Module32Next(hSnapshot, &moduleEntry));
    }

    char** moduleNames = new char*[count];
    int index = 0;

    // Reset snapshot to beginning
    Module32First(hSnapshot, &moduleEntry);

    if (!Module32First(hSnapshot, &moduleEntry)) {
        warn("PID: %-6d, [Module32First] failed to get module info, Error: %lx", PID, GetLastError());
        CloseHandle(hSnapshot);
        return nullptr;
    }
    do {
        moduleNames[index] = new char[MAX_MODULE_NAME32];
        strncpy(moduleNames[index], moduleEntry.szModule, MAX_MODULE_NAME32 - 1);
        moduleNames[index][MAX_MODULE_NAME32 - 1] = '\0';
        if (index == 0){
            debug("Name of module: %s", moduleEntry.szModule);
            get_exported_functions(PID, moduleEntry.szModule);
        }
        ++index;
        //Remember to place here the import/export table

        //info("  %s", moduleEntry.szModule);
        //info("Module name: %s", moduleEntry.szModule);
        //info("Executable path: %s", moduleEntry.szExePath);
        //info("Base address: 0x%p", (void*)moduleEntry.modBaseAddr);
        //info("Module size: %lu bytes\n", moduleEntry.modBaseSize);
    } while (Module32Next(hSnapshot, &moduleEntry));

    CloseHandle(hSnapshot);
    *numModules = count;
    okay("PID: %-6d, Granted Access", PID);
    return moduleNames;
}

void free_module_names(char** moduleNames, int numModules) {
    
    if (moduleNames) {
        for (int i = 0; i < numModules; ++i) {
            delete[] moduleNames[i];
        }
        delete[] moduleNames;
    }
}

BOOL write_data_in_nx_format(ProcessInfo *processList, int numProcesses) {
    // Write List of PIDs in networkx format
    FILE* outputFile = fopen("../list_PIDs.txt", "w");
    if (!outputFile) {
        fprintf(stderr, "Error opening file for writing!\n");
        warn("[fopen] failed to open file. Error: %lx", GetLastError());
        return false;
    }

    if (processList != NULL) {
        info("Writing in list_PIDs:");
        for (int i = 0; i < numProcesses; i++) {
            //const char* temp_line = <reinterpret_cast>(char*)processList[i].pid;
            fprintf(outputFile, "%s (%d)\n", processList[i].processName, processList[i].pid); 
        }
    } else { return false; }

    fclose(outputFile);
    okay("Operation Success!");
    //return TRUE;

    // Write edges from PIDs to MODULES in networkx format
    outputFile = fopen("../list_MODULES_imports.txt", "w");
    if (!outputFile) {
        fprintf(stderr, "Error opening file for writing!\n");
        warn("[fopen] failed to open file. Error: %lx", GetLastError());
        return false;
    }

    if (processList != NULL) {
        info("Writing in list_MODULES_imports:");
        for (int i = 0; i < numProcesses; i++) {
            int numModules = 0;
            char** moduleNames = get_all_modules_info_of_PID(processList[i].pid, &numModules);
            if (moduleNames) {
                for (int j = 0; j < numModules; ++j) {
                    fprintf(outputFile, "%s (%d), %s\n", moduleNames[0], processList[i].pid, moduleNames[j]); 
                }
                free_module_names(moduleNames, numModules);
            } else {
                //pass
            }
        }
    } else { return false; }

    fclose(outputFile);
    okay("Operation Success!");
    return true;
}

void setup_debug_mode(int argc, char* argv[]) {
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-debug") == 0) {
            debugEnabled = true;
            okay("Debug mode enabled.\n");
        }
    }
}

ProcessInfo* print_all_PIDs(int *numProcesses) {
    // Create snapshot of all running processes
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        warn("[CreateToolhelp32Snapshot] failed to create snapshot. Error: %lx\n", GetLastError());
        *numProcesses = 0;
        return NULL;
    }

    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &processEntry)) {
        warn("[Process32First] failed to get first process. Error: %lx\n", GetLastError());
        CloseHandle(hSnapshot);
        *numProcesses = 0;
        return NULL;
    }

    int initialSize = 256;
    ProcessInfo *processList = (ProcessInfo*)malloc(initialSize * sizeof(ProcessInfo));
    if (processList == NULL) {
        warn("[malloc] allocation failed. Error: %lx\n", GetLastError());
        CloseHandle(hSnapshot);
        *numProcesses = 0;
        return NULL;
    }

    int currentSize = 0;

    do {
        if (currentSize >= initialSize) {
            initialSize *= 2;
            ProcessInfo *temp = (ProcessInfo *)realloc(processList, initialSize * sizeof(ProcessInfo));
            if (temp == NULL) {
                warn("[realloc] reallocation failed. Error: %lx\n", GetLastError());
                free(processList);
                CloseHandle(hSnapshot);
                *numProcesses = 0;
                return NULL;
            }
            processList = temp;
        }

        BOOL must_skip_this_process = false;
        for (int i = 0; i < sizeof(list_of_ignored_processes)/sizeof(list_of_ignored_processes[0]); i++){
            if (strcmp(processEntry.szExeFile, list_of_ignored_processes[i]) == 0){
                debug("Skipped %s", processEntry.szExeFile);
                must_skip_this_process = true;
            }
        }
        if (must_skip_this_process){ continue; }

        processList[currentSize].pid = processEntry.th32ProcessID;
        strncpy(processList[currentSize].processName, processEntry.szExeFile, MAX_NAME_LENGTH - 1);
        processList[currentSize].processName[MAX_NAME_LENGTH - 1] = '\0'; // Ensure null termination
        currentSize++;
    } while (Process32Next(hSnapshot, &processEntry));

    CloseHandle(hSnapshot);
    *numProcesses = currentSize;
    return processList;
}

HANDLE attempt_get_handle_to_process(int PID) {
    
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
    if (!hProcess){
        warn("[OpenProcess] failed to access %d, Error: %lx", PID, GetLastError());
        return nullptr;
    }
    return hProcess;
}

int mainRoutine() {

    //int useThisPID;
    //info("Insert PID");
    //scanf("%d", &useThisPID);
    //print_from_PID_all_modules_info(useThisPID);
    int numProcesses;
    ProcessInfo* processList = print_all_PIDs(&numProcesses);

    if (processList != NULL) {
        info("List of Processes:\n");
        for (int i = 0; i < numProcesses; i++) {
            info("PID: %-6d, Process Name: %s", processList[i].pid, processList[i].processName);

            /*
            int numModules = 0;
            char** moduleNames = get_all_modules_info_of_PID(processList[i].pid, &numModules);
            if (moduleNames) {
                for (int i = 0; i < numModules; ++i) {
                    info("  %s", moduleNames[i]);
                }

                free_module_names(moduleNames, numModules);
            } else {
                warn("Failed to retrieve module names for PID %d", processList[i].pid);
            }
            */
 
        }
    } else {
        warn("Failed to retrieve list of processes");
    }

    write_data_in_nx_format(processList, numProcesses);

    free(processList);
    return 0;
}

int main(int argc, char* argv[]) {

    system("cls");
    setup_debug_mode(argc, argv);

    // Run the main routine in the main thread
    mainRoutine();

    return 0;
}