#include "../imports.h"
#include <psapi.h>

#pragma comment(lib, "psapi.lib")

LPVOID getRemoteProcAddress(char* dllName, char* procName, int targetPid);
void injectCode(int hookPid, int protectPid, char* dllName, char* procName);
LPVOID injectTrampoline(HANDLE hProcess, int protectPid);
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes);


/*
    This code args are 
    hookPid: what PID we r going to inject code into
    protectPid: what PID we want to deny access with OpenProcess
*/
int main(int argc, char *argv[]) {
    int hookPid;
    int protectPid;
    if (argc < 5) {
        info("Usage: %s <hookPid> <protectPid>\n", argv[0]);
        hookPid = 5348;
        protectPid = 6324;
    } 
    else {
        hookPid = atoi(argv[1]);
        protectPid = atoi(argv[2]);
    }

	injectCode(5348, 6324, "ntdll.dll", "NtOpenProcess");
	system("pause");
    return 0;
}

// Return the memory address in a targetPid in which a function procName from dllName is called
LPVOID getRemoteProcAddress(char* dllName, char* procName, int targetPid) {
    /*
        This function uses the local offset of given function (procName) in a dll (dllName) to calculate 
        the address of the same function in the desired remote process (targetPid).

        Order of actions:
        Attempt to open a HANDLE to the process of targetPID with all permissions
            if failure, returns nothing
        Attempt to store the size of buffer needed to store the module handles used in the process
            if failure, returns nothing
        Store a list of module handles and iterate over all of them
        Check if the names are 8bits and if name is dllName
        Stores local offset of wanted procName in dllName
        Uses the offset to calculate the remote address of function call using hModule address
        Return the LPVOID retval address. 
    */
	LPVOID retval = NULL;
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);

	if (hProcess) {
		DWORD reqSizeOfBuffer = 0;
        /*  BOOL EnumProcessModulesEx(...)
            BOOL EnumProcessModulesEx(
                [in]  HANDLE  hProcess,
                [out] HMODULE *lphModule,
                [in]  DWORD   cb,
                [out] LPDWORD lpcbNeeded,
                [in]  DWORD   dwFilterFlag
            );

            Description
            Retrieves a handle for each module in the specified process that meets the specified filter criteria.

            Parameters
            [in] hProcess
            A handle to the process.
            [out] lphModule
            An array that receives the list of module handles.
            [in] cb
            The size of the lphModule array, in bytes.
            [out] lpcbNeeded
            The number of bytes required to store all module handles in the lphModule array.
            [in] dwFilterFlag
            The filter criteria. This parameter can be one of the following values.
        */
		if (EnumProcessModulesEx(hProcess, 0, 0, &reqSizeOfBuffer, LIST_MODULES_64BIT)) {
            // Return the size of buffer required to store the module handles and pass it 
            // to reqSizeOfBuffer.

			HMODULE* modulesBuffer = (HMODULE*)malloc(reqSizeOfBuffer);
            // Size of modulesBuffer is allocated dinamically

			if (EnumProcessModulesEx(hProcess, modulesBuffer, reqSizeOfBuffer, &reqSizeOfBuffer, LIST_MODULES_64BIT)) {
                // Now we call EnumProcessModulesEx with modulesBuffer and reqSizeOfBuffer to fill the first one with
                // module handles

				int sizeOfHMODULE = sizeof(HMODULE);
				int numberOfModules = reqSizeOfBuffer / sizeOfHMODULE; // Here we get the amount of modules
				for (int i = 0; i < numberOfModules; i++) {
                    // Here we iterate over the modules to find target dll: dllName

					HMODULE hModule = modulesBuffer[i];
					char* moduleName = (char*)calloc(256, sizeof(char));
                    /*  DWORD GetModuleBaseNameA(...)
                        DWORD GetModuleBaseNameA(
                            [in]           HANDLE  hProcess,
                            [in, optional] HMODULE hModule,
                            [out]          LPSTR   lpBaseName,
                            [in]           DWORD   nSize
                        );

                        Description
                        Retrieves the base name of the specified module.

                        Parameters
                        [in] hProcess
                        A handle to the process that contains the module.
                        The handle must have the PROCESS_QUERY_INFORMATION and PROCESS_VM_READ access rights. 
                        For more information, see Process Security and Access Rights.
                        [in, optional] hModule
                        A handle to the module. If this parameter is NULL, this function returns the name of the file 
                        used to create the calling process.
                        [out] lpBaseName
                        A pointer to the buffer that receives the base name of the module. If the base name is longer 
                        than maximum number of characters specified by the nSize parameter, the base name is truncated.
                        [in] nSize
                        The size of the lpBaseName buffer, in characters.
                        */
					if (GetModuleBaseName(hProcess, hModule, moduleName, 256) <= 256) {
                        // Store the hModule name in moduleName variable, which has size 256
                        // The condition is for failsafe purpose.

						if (_stricmp(moduleName, dllName) == 0) { 
                            // Case insensitive strcmp

                            /*  HMODULE GetModuleHandle(...)
                                libloaderapi.h define GetModuleHandle as the same of GetModuleHandleA
                                which is the default WindowsAPI function. 
                            */ 
							HMODULE localModuleAddress = GetModuleHandle(dllName);
                            // Retrieves a module handle for the specified module. 
                            // The module must have been loaded by the calling process.                       
                            /*  FARPROC GetProcAddress(...)

                            FARPROC GetProcAddress(
                                [in] HMODULE hModule,
                                [in] LPCSTR  lpProcName
                            );

                            Description
                            Retrieves the address of an exported function (also known as a procedure) or 
                            variable from the specified dynamic-link library (DLL).

                            Parameters
                            [in] hModule
                            A handle to the DLL module that contains the function or variable. The LoadLibrary, 
                            LoadLibraryEx, LoadPackagedLibrary, or GetModuleHandle function returns this handle.
                            The GetProcAddress function does not retrieve addresses from modules that were loaded 
                            using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx.
                            [in] lpProcName
                            The function or variable name, or the function's ordinal value. If this parameter is 
                            an ordinal value, it must be in the low-order word; the high-order word must be zero.
                            */
                            FARPROC localProcAddress = GetProcAddress(localModuleAddress, procName);
                            // If the function succeeds, the return value is the address of the exported function or variable.

							DWORD offset = (DWORD)localProcAddress - (DWORD)localModuleAddress;
							retval = (LPVOID)((DWORD)hModule + offset);
                            // DWORD offset is equals to the difference of memory addresses, which is add to hModule
                            // to retrieve the address of the procName in the remote process.
                            /*  Example
                                dllName = kernel32.dll 
                                procName = OpenProcess

                                LocalProcess (The process which is running this code)
                                Base address of kernel32.dll (localModuleAddress): 0x10000000
                                Address of OpenProcess within kernel32.dll (localProcAddress): 0x1000B456
                                DWORD offset = 0x1000B456 - 0x10000000 = 0xB456

                                RemoteProcess
                                Base address of kernel32.dll (hModule): 0x30000000 (In this case, as a example)
                                retval = (LPVOID)((DWORD)0x30000000 + 0xB456) = (LPVOID)0x3000B456
                            */
							break;
						}
					}
				}
			}
		}
        // Now we close the handle to the targetPid process.
		CloseHandle(hProcess);
	}
    // Returns pointer to address of procName function.
	return retval;
}

// Primary function, inject shellcode by calling getRemoteProcAddress, injectTrampoline and writeNOPs
void injectCode(int hookPid, int protectPid, char* dllName, char* procName) {

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, hookPid);
	
    if (hProcess) {
        // Calls personalized getProcAddress function
		LPVOID hookAtAddress = getRemoteProcAddress(dllName, procName, hookPid);
        // Returns a address of hookPID in which procName of dllName is called.

		if (hookAtAddress) {
            // Calls personalized shellcode injection function
			LPVOID trampolineAddress = injectTrampoline(hProcess, protectPid);
            // Returns a address to the modified ntdll function
			if (trampolineAddress) {

				char jumpBytes[] = { 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0xFF, 0xE0 };
				/*
				00000000777C9B00 | B8 EF BE AD DE           | mov eax,DEADBEEF                               |
				00000000777C9B05 | FF E0                    | jmp rax                                        |
				*/

                // Overwrite {...,0xEF, 0xBE, 0xAD, 0xDE,...} with the address of trampolineAddress
				memcpy(&jumpBytes[1], &trampolineAddress, 4); //patch DEADBEEF to trampolineAddress
				int sizeOfJumpBytes = sizeof(jumpBytes);

				if (writeNOPs(hProcess, hookAtAddress, 11)) 
                // NOP out 11 bytes in remote process at hookAtAddress
                // Cleaning memory to insert jumpBytes without conflicts
				{
					SIZE_T numBytesWritten = 0;
					if (!WriteProcessMemory(hProcess, hookAtAddress, jumpBytes, sizeOfJumpBytes, &numBytesWritten) || numBytesWritten != sizeOfJumpBytes) { 
                        //Write jumpBytes to remote process
						printf("WriteProcessMemory at %0x4 failed!\n", hookAtAddress);
					}
					else {
						printf("Inline hook set!\n");
					}
				}
				/*
				Say it is NtOpenProcess that we're hooking in the remote process. Before writing our jump bytes, the remote memory starting at hookAtAddress looks like: (x64dbg)

				...............
				00000000777C9B00 | 4C 8B D1                 | mov r10,rcx                                    | NtOpenProcess
				00000000777C9B03 | B8 23 00 00 00           | mov eax,23                                     | 23:'#'
				00000000777C9B08 | 0F 05                    | syscall                                        |
				00000000777C9B0A | C3                       | ret                                            |
				00000000777C9B0B | 0F 1F 44 00 00           | nop dword ptr ds:[rax+rax],eax                 |
				00000000777C9B10 | 4C 8B D1                 | mov r10,rcx                                    | NtSetInformationFile
				00000000777C9B13 | B8 24 00 00 00           | mov eax,24                                     | 24:'$'
				00000000777C9B18 | 0F 05                    | syscall                                        |
				00000000777C9B1A | C3                       | ret                                            |
				00000000777C9B1B | 0F 1F 44 00 00           | nop dword ptr ds:[rax+rax],eax                 |
				00000000777C9B20 | 4C 8B D1                 | mov r10,rcx                                    | ZwMapViewOfSection
				00000000777C9B23 | B8 25 00 00 00           | mov eax,25                                     | 25:'%'
				00000000777C9B28 | 0F 05                    | syscall                                        |
				00000000777C9B2A | C3                       | ret                                            |
				...............

				Upon close inspection, it is immediately clear that each ntdll function has 11 bytes starting from 4C and ending at C3 i.e. for our case, the following:

				00000000777C9B00 | 4C 8B D1                 | mov r10,rcx                                    | NtOpenProcess
				00000000777C9B03 | B8 23 00 00 00           | mov eax,23                                     | 23:'#'
				00000000777C9B08 | 0F 05                    | syscall                                        |
				00000000777C9B0A | C3                       | ret                                            |

				I don't know why or how the nop dword ptr ds:[rax+rax],eax comes into play, but GetProcAddress on any ntdll function points to a mov r10,rcx address
				The only difference between the otherwise completely different ntdll functions is the syscall id moved into eax at the 5th byte starting from 4C
				Anyway, we then NOP out the 11 familiar bytes to get, unremarkably, the following, eleven 0x90 bytes:

				00000000777C9B00 | 90                       | nop                                            | NtOpenProcess
				00000000777C9B01 | 90                       | nop                                            |
				00000000777C9B02 | 90                       | nop                                            |
				00000000777C9B03 | 90                       | nop                                            |
				00000000777C9B04 | 90                       | nop                                            |
				00000000777C9B05 | 90                       | nop                                            |
				00000000777C9B06 | 90                       | nop                                            |
				00000000777C9B07 | 90                       | nop                                            |
				00000000777C9B08 | 90                       | nop                                            |
				00000000777C9B09 | 90                       | nop                                            |
				00000000777C9B0A | 90                       | nop                                            |

				Upon successful NOPing, we bluntly write our redirection jump code:

				00000000777C9B00 | B8 EF BE AD DE           | mov eax,DEADBEEF                               |
				00000000777C9B05 | FF E0                    | jmp rax                                        |
				00000000777C9B07 | 90                       | nop                                            |
				00000000777C9B08 | 90                       | nop                                            |
				00000000777C9B09 | 90                       | nop                                            |
				00000000777C9B0A | 90                       | nop                                            |

				Whatever of the NOPs remain, we do not care. Our trampoline function subsumes the default functionality of the original 11 bytes - along with our filter logic of course
				*/
				/*
				NOTE: Since VirtualAllocEx() to allocate memory for trampoline seems to return 4-byte(32-bit) address even in x64 compilation, the | MOV EAX,DEADBEEF | JMP RAX | jump code works.
				If however VirtualAllocEx() gives back an address greater than FFFFFFFF, which can theoretically happen in x64 compilation, the JMP RAX bytes will be overwritten and things will go haywire.
				So, it will be safest to prepare for that and NOP out not 11 bytes at the hook address but 16 bytes since then we'll require a new bigger jump code.
				The remote memory should look like below after patching:
				00000000777C9B00 | 48 B8 32 54 76 98 78 56 34 12        | mov rax,1234567898765432                       | NtOpenProcess
				00000000777C9B0A | FF E0                                | jmp rax                                        |
				00000000777C9B0C | 90                                   | nop                                            |
				00000000777C9B0D | 90                                   | nop                                            |
				00000000777C9B0E | 90                                   | nop                                            |
				00000000777C9B0F | 90                                   | nop                                            |
				Notice that the jumpBytes[] array will need to be like {0x48,0xB8,0x32,0x54,0x76,0x98,0x78,0x56,0x34,0x12,0xFF,0xE0}, which is 12 bytes long; 
				also note the trampoline address will need to be patched at jumpBytes[2] and not at jumpBytes[1] 
				Contrast that with the current implementation's patch :
				00000000777C9B00 | B8 00 00 03 02                       | mov eax,2030000                                | NtOpenProcess
				00000000777C9B05 | FF E0                                | jmp rax                                        |
				00000000777C9B07 | 90                                   | nop                                            |
				00000000777C9B08 | 90                                   | nop                                            |
				00000000777C9B09 | 90                                   | nop                                            |
				00000000777C9B0A | 90                                   | nop                                            |
				00000000777C9B0B | 0F 1F 44 00 00                       | nop dword ptr ds:[rax+rax],eax                 |
				And with the original disassembly :
				00000000777C9B00 | 4C 8B D1                             | mov r10,rcx                                    | NtOpenProcess
				00000000777C9B03 | B8 23 00 00 00                       | mov eax,23                                     | 23:'#'
				00000000777C9B08 | 0F 05                                | syscall                                        |
				00000000777C9B0A | C3                                   | ret                                            |
				00000000777C9B0B | 0F 1F 44 00 00                       | nop dword ptr ds:[rax+rax],eax                 |

				*/
			}
			else {
				printf("Trampoline injection failed!\n");
			}
		}
		else {
			printf("Couldn't find %s!%s in remote process!\n", dllName, procName);
		}
		CloseHandle(hProcess);	
	}
	else {
		printf("OpenProcess failed!\n");
	}
}

/*  Description: 
    Inject code in hProcess to deny access to protectPID, 
    modifying NtOpenProcess (located at ntdll.dll, appear in Ntddk.h)
    (Which is called by OpenProcess in 	Kernel32.dll (WindowsAPI)) 
*/
LPVOID injectTrampoline(HANDLE hProcess, int protectPid) {

	char trampolineOpcodes[] = { 0x41,0x8B,0x01,0x3D,0x84,0x10,0x00,0x00,0x75,0x06,0xB8,0x22,0x00,0x00,0xC0,0xC3,0x4C,0x8B,0xD1,0xB8,0x23,0x00,0x00,0x00,0x0F,0x05,0xC3 };
	/*
	PSEUDO-ASM:
	1	mov eax, dword ptr [r9]  -->R9 register contains the pointer to CLIENT_ID structure whose first DWORD is ProcessId
	2	cmp eax,1084             -->compare with our desired ProcessId to protect (Decimal 4100)
	3	jne 6                    -->if not equal, goto third line from here
	4	mov eax,c0000022         -->EAX register, which contains the return value, is assigned 0xc0000022 i.e. STATUS_ACCESS_DENIED
	5	ret                      -->return to kernel32.dll module with the STATUS_ACCESS_DENIED output
	6	mov r10,rcx              --------------------------------\
	7	mov eax,23               --(syscall id for NtOpenProcess)-\__[standard code in any Ntdll function]
	8	syscall                  ---------------------------------/
	9	ret                      --------------------------------/

	ACTUAL DISASSEMBLY (x64dbg):
	00000000001A0000 | 41 8B 01                 | mov eax,dword ptr ds:[r9]                      |
	00000000001A0003 | 3D 84 10 00 00           | cmp eax,1084                                   |
	00000000001A0008 | 75 06                    | jne 1A0010                                     |
	00000000001A000A | B8 22 00 00 C0           | mov eax,C0000022                               |
	00000000001A000F | C3                       | ret                                            |
	00000000001A0010 | 4C 8B D1                 | mov r10,rcx                                    |
	00000000001A0013 | B8 23 00 00 00           | mov eax,23                                     | 23:'#'
	00000000001A0018 | 0F 05                    | syscall                                        |
	00000000001A001A | C3                       | ret                                            |

	Note: I had first avoided the mov eax,C0000022 line but it resulted in an INVALID_HANDLE_EXCEPTION (or sth like that). I looked up the return value of NtOpenProcess
	and x64 calling conventions and it turns out : (msdn)
	"A scalar return value that can fit into 64 bits is returned through RAX..."
	Whew! At least there's one thing in common with x86
	So, I decided to give a STATUS_ACCESS_DENIED return value (0xC0000022); and that stopped the exception and as a bonus, the hooked application(Win7 x64 taskmanager in my case)
	gave me a warm "Access is denied" error message upon trying to end the protected process.
	*/

    // Write protectPid starting in position 4 on trampolineOpcodes, which will overwrite 
    // the block {...,0x84,0x10,0x00,0x00,...} (Size 4)
	memcpy(&trampolineOpcodes[4], &protectPid, 4);  //patch the PID to protect
	long sizeOfTrampoline = sizeof(trampolineOpcodes);  // Store size of shellcode so that we can alloc and write in memory

    // Get address of Process, passing size to be allocated, type of allocation and permissions. 
	LPVOID lpAddressTrampoline = VirtualAllocEx(hProcess, 0, sizeOfTrampoline, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    /*  VirtualAllocEx(...)
        LPVOID VirtualAllocEx(
            [in]           HANDLE hProcess,
            [in, optional] LPVOID lpAddress,
            [in]           SIZE_T dwSize,
            [in]           DWORD  flAllocationType,
            [in]           DWORD  flProtect
        );

        Description
        Reserves, commits, or changes the state of a region of memory within the virtual address space 
        of a specified process. The function initializes the memory it allocates to zero.

        Parameters
        [in] hProcess
            The handle to a process. The function allocates memory within the virtual address space of this process.
            The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security 
            and Access Rights.
        [in, optional] lpAddress
            The pointer that specifies a desired starting address for the region of pages that you want to allocate.
            If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation 
            granularity.
            If you are committing memory that is already reserved, the function rounds this address down to the nearest 
            page boundary. To determine the size of a page and the allocation granularity on the host computer, use the 
            GetSystemInfo function.
            If lpAddress is NULL, the function determines where to allocate the region.
            If this address is within an enclave that you have not initialized by calling InitializeEnclave, VirtualAllocEx 
            allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will 
            not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.
            If the address in within an enclave that you initialized, then the allocation operation fails with the 
            ERROR_INVALID_ADDRESS error. That is true for enclaves that do not support dynamic memory management (i.e. SGX1). 
            SGX2 enclaves will permit allocation, and the page must be accepted by the enclave after it has been allocated.
        [in] dwSize
            The size of the region of memory to allocate, in bytes.
            If lpAddress is NULL, the function rounds dwSize up to the next page boundary.
            If lpAddress is not NULL, the function allocates all pages that contain one or more bytes in the range from 
            lpAddress to lpAddress+dwSize. This means, for example, that a 2-byte range that straddles a page boundary 
            causes the function to allocate both pages.
        [in] flAllocationType
            The type of memory allocation. This parameter must contain one of the following values.
                MEM_COMMIT       0x00001000
                MEM_RESERVE      0x00002000
                MEM_RESET        0x00080000
                MEM_RESET_UNDO   0x1000000
                MEM_LARGE_PAGES  0x20000000
                MEM_PHYSICAL     0x00400000
                MEM_TOP_DOWN     0x00100000
        [in] flProtect
            The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.
            If lpAddress specifies an address within an enclave, flProtect cannot be any of the following values:
                PAGE_NOACCESS
                PAGE_GUARD
                PAGE_NOCACHE
                PAGE_WRITECOMBINE
            When allocating dynamic memory for an enclave, the flProtect parameter must be PAGE_READWRITE or PAGE_EXECUTE_READWRITE.
    */
	
    if (lpAddressTrampoline) {
		SIZE_T bytesWritten = 0;
        // Write trampolineOpcodes with size sizeOfTrampoline in hProcess (With write permissions), 
        // on address lpAddressTrampoline. Saving the number of bytes written on bytesWritten and them
        // compare to check if the injection worked.
		if (WriteProcessMemory(hProcess, lpAddressTrampoline, trampolineOpcodes, sizeOfTrampoline, &bytesWritten) && bytesWritten == sizeOfTrampoline) {
			printf("Wrote trampoline to remote process successfully!\n");
		}
		else {
			printf("WriteProcessMemory failed!\n");
			if (VirtualFreeEx(hProcess, lpAddressTrampoline, 0, MEM_RELEASE)) {
			}
		}
	}
	else {
		printf("VirtualAllocEx failed!\n");
	}
    // Return the address of the trampoline injected shellcode
	return lpAddressTrampoline;
}

// Write no function instruction to shellcode
BOOL writeNOPs(HANDLE hProcess, LPVOID lpAddress, int numBytes) {
    // retval return TRUE if writing finished without errors.
	BOOL retval = FALSE;

    // Alloc memory for a array of numBytes chars. 
	char* nopArray = (char*)calloc(numBytes, sizeof(char));
	char nop = 0x90;  //Hex code for "do nothing"
	for (int i = 0; i < numBytes; i++) {
		memcpy(&nopArray[i], &nop, 1);  //fill buffer with NOP bytes
	}

	if (hProcess) {
		SIZE_T numBytesWritten = 0;
		if (WriteProcessMemory(hProcess, lpAddress, nopArray, numBytes, &numBytesWritten)) {
            //write NOPs to remote process
			if (numBytesWritten == numBytes)
				retval = TRUE;
		}
	}

	return retval;
}